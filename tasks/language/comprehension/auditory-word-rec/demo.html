<!DOCTYPE html>
<html>
  <head>
    <title>Auditory Word Recognition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link type="text/css" rel="stylesheet" href="../../../../css/page.css"/>
    <link type="text/css" rel="stylesheet" href="../../../../css/button.css"/>
    <link type="text/css" rel="stylesheet" href="../../../../css/chart.css"/>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../libs/progress_bar.js"></script>
  </head>
  <body>
      <div id="instructions">
          <h1>Auditory Word Recognition</h1>
          <p>During this experiment you will be spoken a series of words, one
          at a time. Your task is to determine if each word is a real English
          word or if it is a made-up nonword.</p>
          <ul>
            <li>If the word is a real English word, press the Left Arrow key</li>
            <li>If the word is a made-up nonword, press the Right Arrow key</li>
           </ul>
           <p>Your response time (how quickly you can determine if each word is
           a real word or not) will be measured while you preform the task. Please try to respond as quickly and accurately as you can.</p>

           <p>After each response (or 2 seconds if you do not respond) the next word will be presented automatically.</p>

           <p>A bar running along the bottom of the screen will track your
           progress. This experiment should take about two minutes to
           complete.</p>
           <p class="begin">This experiment requires sound.<br/> Be sure your
           speakers or headphones are turned on and at an appropriate volume.</p>
           <p class="begin">Press the spacebar when you are ready to begin!</p>
      </div>
      <div class="results">
              <h1>Auditory Word Recognition</h1>

              <h2>Results and Explanation</h1>

              <p>This experiment was designed to examine one aspect of how we
              recognize spoke words. In particular, it looked at whether
              the mental representation of words can be divided along semantic
              and syntactic dimensions such that nouns and verbs are represented
              as particularly distinct from each other.</p>
              
              <p>To test this, the experiment used a <a
                  href="http://en.wikipedia.org/wiki/Lexical_decision_task">Lexical
                  Decision Task</a> with three different categories of real words and
              a collection of made-up non-words. The first category of real
              words was unambiguous words, those with one clear mean (e.g.,
              'scissors'). The other two categories were composed of words that
              are homonyms, meaning the same spelling and pronunciation refers
              to two different meanings. The second category of words were
              noun-verb homonyms, meaning one of the meanings refers to a verb
              while the other refers to a noun (e.g., 'fly' the insect [noun]
              and 'fly' the act of moving through the air). The third and final
              category consisted of noun-noun homonyms, where the two meanings
              both refer to different nouns (e.g., 'chest' the upper part of the
              torso and 'chest' the container to store your treasure).</p>

              The logic behind the choices of these categories is as follows:
              The unambiguous words should be easy to identify and ascribe
              meaning to, so responses should be quick that they are real words.
              The noun-verb homonyms will lead to some interference, but if
              nouns and verbs are generally represented separately, this
              interference should be small and result in only a slight slowing
              in the response. Finally, the noun-noun homonyms will result in
              considerable interference and thus the longest response time.</a>

              <p>In a <a
                  href="http://dx.doi.org/10.1111/j.1551-6709.2009.01069.x">
                  2010 study</a>, Daniel Mirman and colleagues found exactly that.
              Participants were slower to respond (i.e., had a larger reaction
              time) to the noun-verb homonyms than to
              the unambiguous words, and were even slower to respond to the
              noun-noun homonyms. Additionally, participants made considerably
              more errors (calling a word a non-word) for the noun-noun homonyms
              compared to the other words. How do you stack up?
              Below you can see your reaction time (or error rate) for each of
              the categories of words, or you can switch to viewing the original
              results from Mirman and colleagues' study by clicking the 'Study
              Data' button.</p>

              <p>The results from this study and others suggest that spoken word
              recognition is a complicated process, with multiple meanings for
              words interacting and interfering with one and other.

              <div id="controls">
                  <span id="who"><button class="first active">Your Data</button><button class="last">Study Data</button></span>
                  <span id="what"><button class="first active">Response Times</button><button class="last">Errors</button></span>
              </div>
      </div>
      <div id="chart">
      </div>
      <div class='results'>
          <div id="ccontrols">
              <span id="return"><button class="first last"
                      onclick="window.location='../#auditory'">Back to Overview</button></span>
          </div>
      </div>
      <script type="text/javascript">

var width = window.innerWidth*.8;
    height = window.innerHeight*.8;

var margins = [100, 100, 10, 100], mb = margins[0], ml = margins[1], mt = margins[2], mr = margins[3];
var w = width - (ml + mr),
    h = height - (mb + mt);
var x = d3.scale.linear().range([0, w]).domain([-1,3]);
var y = d3.scale.linear().range([h, 0]).domain([400,700]);
var yAxis = d3.svg.axis().scale(y).ticks(4).orient("left");
var yAxisGrid = d3.svg.axis().scale(y).ticks(4).tickSize(-w).orient("right");

var bar_width = 100;

var words = [{'type':'non-word','word':'grourn'},
{'type':'non-word','word':'clett'},
{'type':'non-word','word':'stilch'},
{'type':'non-word','word':'fusk'},   
{'type':'non-word','word':'trebe'},  
{'type':'non-word','word':'tarb'},   
{'type':'non-word','word':'crolt'},  
{'type':'non-word','word':'flane'},  
{'type':'non-word','word':'plail'},  
{'type':'non-word','word':'chuth'},  
{'type':'non-word','word':'knush'},  
{'type':'non-word','word':'thafe'},  
{'type':'non-word','word':'slont'},  
{'type':'non-word','word':'boathe'}, 
{'type':'non-word','word':'stryne'}, 
{'type':'non-word','word':'trewt'},  
{'type':'non-word','word':'spresh'}, 
{'type':'non-word','word':'reuth'},  
{'type':'non-word','word':'weff'},   
{'type':'non-word','word':'ciff'},   
{'type':'non-word','word':'pudd'},   
{'type':'non-word','word':'poy'},    
{'type':'non-word','word':'phuib'},  
{'type':'non-word','word':'brulk'},  
{'type':'non-word','word':'knurke'}, 
{'type':'non-word','word':'trorth'}, 
{'type':'non-word','word':'neech'},  
{'type':'non-word','word':'frult'},  
{'type':'non-word','word':'dern'},   
{'type':'non-word','word':'lafe'},   
{'type':'non-word','word':'gnach'},  
{'type':'non-word','word':'gnake'},  
{'type':'non-word','word':'thrail'}, 
{'type':'non-word','word':'jorque'}, 
{'type':'non-word','word':'vique'},  
{'type':'non-word','word':'speem'},  
{'type':'non-word','word':'thwez'},  
{'type':'non-word','word':'throg'},  
{'type':'non-word','word':'wouse'},  
{'type':'non-word','word':'pess'},   
{'type':'noun-noun','word':'bolt'},
{'type':'noun-noun','word':'chest'},  
{'type':'noun-noun','word':'court'},  
{'type':'noun-noun','word':'crane'},  
{'type':'noun-noun','word':'deck'},  
{'type':'noun-noun','word':'fan'},
{'type':'noun-noun','word':'glass'},
{'type':'noun-noun','word':'mint'},  
{'type':'noun-noun','word':'organ'},  
{'type':'noun-noun','word':'palm'},  
{'type':'noun-noun','word':'ruler'},  
{'type':'noun-noun','word':'straw'},  
{'type':'noun-noun','word':'temple'},
{'type':'noun-verb','word':'bark'},
{'type':'noun-verb','word':'bowl'},  
{'type':'noun-verb','word':'count'},  
{'type':'noun-verb','word':'fly'},  
{'type':'noun-verb','word':'hamper'},  
{'type':'noun-verb','word':'park'},
{'type':'noun-verb','word':'prune'},
{'type':'noun-verb','word':'register'},  
{'type':'noun-verb','word':'ring'},  
{'type':'noun-verb','word':'seal'},  
{'type':'noun-verb','word':'shed'},
{'type':'noun-verb','word':'swallow'},  
{'type':'noun-verb','word':'train'},
{'type':'unambig','word':'acorn'},
{'type':'unambig','word':'groom'},   
{'type':'unambig','word':'knife'},    
{'type':'unambig','word':'lock'},
{'type':'unambig','word':'mug'},  
{'type':'unambig','word':'scissors'},  
{'type':'unambig','word':'sock'},
{'type':'unambig','word':'tie'},
{'type':'unambig','word':'doctor'},
{'type':'unambig','word':'hammer'},  
{'type':'unambig','word':'lobster'},  
{'type':'unambig','word':'map'},   
{'type':'unambig','word':'pie'},
{'type':'unambig','word':'skirt'},     
{'type':'unambig','word':'tape'}];

words = shuffle(words);
//words = words.slice(0,20);

var trial = 0;
var resps = [];
var rts = [];

var iti = 565;
var fix_dur = 500;
var word_dur = 2000;

var started = false;
var waiting_resp = false;
var start, end;

var a = d3.select('body').selectAll('audio')
            .data(words)
          .enter()
            .append('audio')
                .attr('id',function(d) { return 'audio-'+d.word; } )
                .attr('preload','auto')
                .append('source')
                .attr('src',function(d) { return d.type + '/' + d.word + '.ogg'; })
                    .attr('type','audio/ogg');

var svg = d3.select('#chart').append('svg:svg')
    .attr('class', 'chart')
    .style('display','none')
    .attr("width", width)
    .attr("height", height);

var fix = svg.append('svg:text')
    .attr('id','fix')
    .style('opacity',0)
    .style('font-size',(height*.1)+'px')
    .text("+")
    .attr('transform','translate('+(width*.5)+','+(height*.5)+')');

add_progress();

d3.select(window).on("keydown", function() {
        switch (d3.event.keyCode) {
          case 27: // Escape
            trial = 1000;
            resp = -111;
            waitin_resp = false;
            break;
          case 32: // space
            resp = 0;
            break;
          case 37: // left
            resp = 1;
            end = new Date().getTime() - start;
            break;
          case 39: // right
            end = new Date().getTime() - start;
            resp = -1;
            break;
          default:
            resp = -999;
            end = -999;
        }

        if (resp != -999) {
            // This cancels the transition that plays the next sound after
            // timeout
            if (resp != -111) {
                d3.select('#fix').transition().delay(0).duration(0).style('opacity',1)
                if (waiting_resp) {
                    resps.push(resp);
                    rts.push(end);
                }
            }

            if (++trial < words.length)
            {
                advance();
            } else {
                theEnd();
            }
        }
});

function advance() {
        if (!started) {
            d3.select('#instructions').transition().duration(0).style('display','none');
            d3.select('svg').transition().duration(0).style('display','inline');
            fix.style('opacity',1)
            started = true;
            trial = 0;
        }

        console.log('advance');
        move_progress(trial,words.length);
        setTimeout(function() {
            EvalSound('audio-'+words[trial].word); 
            waiting_resp = true;
            start = new Date().getTime();
              d3.select('#fix').transition().delay(2000).duration(0).style('opacity',1)
                  .each('end',function(d) { waiting_resp = false;
                      resps.push(-99); rts.push(-1); if (++trial < words.length) {
                      advance();}else{theEnd();} });
                  },
                  1000);
}

var who = 'Subject';
var what = 'RT';

function theEnd() {
    d3.select('#instructions').transition().duration(0).style('display','none');
    d3.select('svg').transition().duration(0).style('display','inline');
    d3.select('#fix').transition().delay(0).duration(0).style('opacity',0)
    computeStats();
    remove_progress();
    plotResults();
    if (location.hash.substring(1)==='results') { 
            who = 'Group';
            d3.selectAll('#who button')
                .classed('active',function(d) { return d == 'Group'; })
    }
    redraw(who,what);
}


// Results plotting

var group_rts = [946,905,867];
var group_errors = [6.0,2.9,3.0];
var subj_rts = [0,0,0];
var subj_errors = [100,100,100];


function computeStats() {
   types = ['noun-noun','noun-verb','unambig'];
   mean_rts = [];
   mean_errors = [];
   for (var i = 0; i < types.length; i++)
    {
        var tmp_rts = [];
        var tmp_errors = [];
        for (var j = 0; j < rts.length; j++)
        {
            if (words[j].type == types[i]) {
                tmp_errors.push(1==resps[j] ? 0 : 1);
                tmp_rts.push(rts[j]);
            }
        }
        mean_rts.push(mean(tmp_rts));
        mean_errors.push(mean(tmp_errors)*100);
    }
    subj_rts = mean_rts;
    subj_errors = mean_errors;
}

function plotResults() {
    d3.select('#fix').transition().delay(0).duration(0).style('opacity',0)
    d3.selectAll('.results').style('display','block');

    var plot = svg.append('g').attr('id','plot').attr('transform','translate('+ml+','+mt+')');

    var groups = ['Noun-Noun','Noun-Verb','Unambiguous'];
    var groups_e = ['E.g.: "chest"','E.g.: "fly"','E.g.: "scissors"'];

    y.domain([d3.min(subj_rts)*.8,d3.max(subj_rts)*1.2]);

    plot.append("g")
          .attr("class", "y grid")
          .attr('transform','translate('+w+',0)')
          .call(yAxisGrid);

    plot.append('g').attr('id','data-bars');

    plot.select('#data-bars').selectAll('.bars').data(subj_rts).enter().append('svg:rect')
                .classed('bars',true)
                .attr('width',bar_width)
                .attr('height',function(d) { return h-y(d); })
                .attr('x',function(d,i) { return x(i)-(bar_width/2); })
                .attr('y',function(d) { return y(d); });

    plot.append("g")
          .attr("class", "y axis")
          .call(yAxis);

    plot.select('.y.axis').append('svg:text')
        .attr('id','ylab')
        .text('Mean Response Time (ms)').style('text-anchor','middle')
        .attr('transform','translate(-85,'+(h/2)+') rotate(-90)');

    plot.select('.y.axis').append('svg:text')
        .attr('id','ylab2')
        .text('<-- Faster ---|--- Slower -->').style('text-anchor','middle')
        .attr('transform','translate(-65,'+(h/2)+') rotate(-90)');

    plot.append("g")
          .attr("class", "x axis")
          .append('svg:line')
            .attr('x2',w)
            .attr('y1',h)
            .attr('y2',h);

    plot.select('.x.axis').append('svg:text')
        .text('Word Category').style('text-anchor','middle')
        .attr('transform','translate('+(w/2)+','+(h+80)+') ');

    plot.select('g.x.axis').selectAll('g.c1').data(groups).enter().append('svg:g')
        .attr('transform',function(d,i) { return 'translate('+x(i)+','+h+')'; })
        .append('svg:text')
            .text(function(d) { return d; })
            .attr('y',18)
            .attr('dy',7);

    plot.select('g.x.axis').selectAll('g.c2').data(groups_e).enter().append('svg:g')
        .attr('transform',function(d,i) { return 'translate('+x(i)+','+h+')'; })
            .style('font-style','italic')
        .append('svg:text')
            .text(function(d) { return d; })
            .attr('y',18)
            .attr('dy',27);

    d3.selectAll("#who button")
        .data(['Subject','Group'])
        .on("click",function(w) {
            who = w;
            redraw(who,what);
            d3.selectAll('#who button')
                .classed('active',function(d) { return d == w; })
        });

    d3.selectAll("#what button")
        .data(['RT','Errors'])
        .on("click",function(w) {
            what = w;
            redraw(who,what);
            d3.selectAll('#what button')
                .classed('active',function(d) { return d == w; })
        });
}

var ylab = 'Mean Response Time (ms)';
var ylab2 = '<-- Faster ---|--- Slower -->';

function redraw(who,what) {
    d3.select('#fix').transition().delay(0).duration(0).style('opacity',0)
    var prevYlab = ylab;
    var prevYlab2 = ylab2;
    if (what == 'RT') {
        var data = who == "Subject" ? subj_rts : group_rts;
        ylab = 'Mean Response Time (ms)';
        ylab2 = '<-- Faster ---|--- Slower -->';
    } else {
        var data = who == "Subject" ? subj_errors : group_errors;
        ylab = 'Mean Percent Error';
        ylab2 = '<-- Fewer ---|--- More -->';
    }

    y.domain([d3.min(data)*.8,d3.max(data)*1.2]);
    var plot = d3.select('#plot');

    plot.selectAll('.bars')
        .data(data)
      .transition()
            .duration(1000)
            .attr('height',function(d) { return h-y(d); })
            .attr('x',function(d,i) { return x(i)-(bar_width/2); })
            .attr('y',function(d) { return y(d); });

    plot.select('.y.axis').transition().duration(1000).call(yAxis);
    plot.select('.y.grid').transition().duration(1000).call(yAxisGrid);
        
    if (prevYlab != ylab) {
        plot.select('#ylab').transition().duration(500).style('opacity',0);
        plot.select('#ylab2').transition().duration(500).style('opacity',0);
        setTimeout( function() { plot.select('#ylab').text(ylab).transition().duration(500).style('opacity',1);},500);
        setTimeout( function() { plot.select('#ylab2').text(ylab2).transition().duration(500).style('opacity',1);},500);
    }
}


function mean(array)
{
 var sum = 0, i;
 for (i = 0; i < array.length; i++)
 {
  sum += array[i];
 }
  return array.length ? sum / array.length : 0;
}

function shuffle(array) {
    var n = array.length, k, t;
    if (n == 0) return false;
    while (--n) {
        k = Math.floor(Math.random() * (n+1));
        t = array[n];
        array[n] = array[k];
        array[k] = t;
    }
    return array;
}

function EvalSound(soundobj){
   var thissound=document.getElementById(soundobj);
   thissound.play();
}

if (location.hash.substring(1)==='results') { 
    console.log('results');
    theEnd();
}


      </script>
  </body>
</html>
